/**
 *
 *  Manage all the code-related error reporting console messages
 *
**/


// Import the `math.h` library
// This library defines special maths-related functions
#include <math.h>

// Define a function that will return a new line for user-provided code errors
char* newErrorLine(){

    // Get the length of the console error messages prefix
    int prefixLength = errorPrefixLength();

    // Allocate memory for the return string
    char* str = calloc(1 + prefixLength + 1, sizeof(char));

    // Generate the new line string
    str[0] = '\n';
    for(int i = 1; i <= prefixLength; i++){

        str[i] = ' ';

    }
    str[prefixLength + 1] = '\0';

    // Return the new line string
    return str;

}

// Define a function that will return a new line for user-provided code warnings
char* newWarnLine(){

    // Get the length of the console error messages prefix
    int prefixLength = warnPrefixLength();

    // Allocate memory for the return string
    char* str = calloc(1 + prefixLength + 1, sizeof(char));

    // Generate the new line string
    str[0] = '\n';
    for(int i = 1; i <= prefixLength; i++){

        str[i] = ' ';

    }
    str[prefixLength + 1] = '\0';

    // Return the new line string
    return str;

}

// Define a function that can return the string of the full path of a report event
char* fullReportPth(const char *reportPth, char *newLine){

    // Allocate memory for the return variable and define the size variable
    int size = 1;
    char *fullPth = calloc(size, sizeof(char));
    fullPth[0] = '\0';

    // Get the length of the `newLine` variable
    int newLineLength = strlen(newLine);

    // Generate the full path string
    int i = -1, l = 0;
    while(reportPth[++i] != '\0'){

        // Allocate memory for the source prefix string
        size += newLineLength + 2 + 1;
        fullPth = realloc(fullPth, (size)*sizeof(char));

        // Copy the source prefix string
        // Using the `strcat` function to copy the new line will cause an error, so stick to this
        // method!
        for(int t = 0; t < newLineLength; t++){

            // Copy the string character by character!
            fullPth[l++] = newLine[t];

        }
        fullPth[l++] = 'a';
        fullPth[l++] = 't';
        fullPth[l++] = ' ';

        // Start copying the current path
        while(reportPth[i] != ':'){

            // Allocate memory for this character
            size++;
            fullPth = realloc(fullPth, (size)*sizeof(char));

            // Copy the current character
            fullPth[l++] = reportPth[i++];

        }

        while(reportPth[i] != '*' && reportPth[i] != '\0'){

            // Allocate memory for this character
            size++;
            fullPth = realloc(fullPth, (size)*sizeof(char));

            // Copy the current character
            fullPth[l++] = reportPth[i++];

        }

    }
    fullPth[l] = '\0';

    // Check for any possible mistakes
    if(size == 1){

        // Free the memory used by the `fullPth` variable
        free(fullPth);

        // Report this error to the user
        consoleError("An invalid report path was generated by the compiler!%s", 1,
                        (consoleColors) ?
                            STRING_CONSOLE_GITHUB_REPORT :
                            STRING_CONSOLE_GITHUB_REPORT_COLORLESS);

    }

    // Return the full report path
    return fullPth;

}

// Define a function that can return the path of the file that contains the error and the error's
// exact position
void reportedFilePth(const char *reportPth, char **returnPth, int *returnLine, int *returnColumn){

    // Allocate memory for the return variable and define the size variable
    int size = 1;
    *returnPth = calloc(size, sizeof(char));
    *returnPth[0] = '\0';

    // Get the path string and the extra info
    int i = -1, l = 0;
    if(reportPth[++i] != '\0'){

        // Start copying the current path
        while(reportPth[i] != ':'){

            // Allocate memory for this character
            size++;
            *returnPth = realloc(*returnPth, (size)*sizeof(char));

            // Copy the current character
            (*returnPth)[l++] = reportPth[i++];

        }
        (*returnPth)[l] = '\0';

        // Prepare a variable to store the string value of the line
        int tmpSize = 1;
        char *tmp = calloc(tmpSize, sizeof(char));

        // Look for the line value string
        l = 0;
        while(reportPth[++i] != ';'){

            // Allocate memory for this character
            tmpSize++;
            tmp = realloc(tmp, (tmpSize)*sizeof(char));

            // Copy the current character
            tmp[l++] = reportPth[i];

        }
        tmp[l] = '\0';

        // Convert the line string value into an int and save it!
        *returnLine = atoi(tmp);

        // Recycle the "tmp" variable for use in the column search
        free(tmp);
        tmpSize = 1;
        tmp = calloc(tmpSize, sizeof(char));

        // Look for the column value string
        l = 0;
        while(reportPth[++i] != '*' && reportPth[i] != '\0'){

            // Allocate memory for this character
            tmpSize++;
            tmp = realloc(tmp, (tmpSize)*sizeof(char));

            // Copy the current character
            tmp[l++] = reportPth[i];

        }
        tmp[l] = '\0';

        // Convert the column string value into an int and save it!
        *returnColumn = atoi(tmp);

        // Free up the memory used by the `tmp` variable
        free(tmp);

    }

    // Check for any possible mistakes
    if(size == 1){

        // Free the memory used by the `*returnPth` variable
        free(*returnPth);

        // Report this error to the user
        consoleError("An invalid report path was generated by the compiler!%s", 1,
                        (consoleColors) ?
                            STRING_CONSOLE_GITHUB_REPORT :
                            STRING_CONSOLE_GITHUB_REPORT_COLORLESS);

    }

}

// Include all the functions that are related to code-blocks
#include "./codeblock.c"

// Define a function that can print both warnings and errors
int reportConsole(const char *format, int type, ...){

    // Create a `__builtin_va_list` list
    __builtin_va_list __local_argv;
    __builtin_va_start(__local_argv, type);

    // Print a prefixed console message
    int result;
    if(FLAG_CONSOLE_ERROR_MESSAGES && type == REPORT_ERROR){

        // Get the return value of the `____printf_prefix` function
        result = ____printf_prefix(format, __local_argv, consoleErrorPrefix(), 0);

        // Record this message
        errorCount++;

    }else if(FLAG_CONSOLE_WARNING_MESSAGES && type == REPORT_WARN){

        // Get the return value of the `____printf_prefix` function
        result = ____printf_prefix(format, __local_argv, consoleWarnPrefix(), 0);

        // Record this message
        warnCount++;

    }

    // Close the opened `__builtin_va_list` list
    __builtin_va_end(__local_argv);

    // Return the int value that the `printf` function would've returned
    return result;

}

// Define a function that will receive report info
void report(const char *eventPth, int caseEndColumn, int caseHeight, const char *reportMsg, int type){

    // eventPth                             The path to the event/code that triggered this report!
    //                                      Event path format:
    //                                       ________________________________________________
    //                                      |                                                |
    //                                      |  <path_3>:0;0*<path_2>:0;0*<path_1>:0;0        |
    //                                      |________________________________________________|
    //
    // caseEndColumn                        The last column in the last line of the reported part
    //                                      that should be marked as a trigger of this report!
    //
    // caseHeight                           The case height represents the number of lines the
    //                                      report-cause stretches to!
    //
    // reportMsg                            The report console message!

    // The final console output will be something like this:
    //  _________________________________________________________
    // |                                                         |
    // |  <report_message>\n                                     |
    // |  at <path_3>:0:0\n                                      |
    // |  at <path_2>:0:0\n                                      |
    // |  at <path_1>:0:0\n                                      |
    // |                                                         |
    // |  <code_block>                                           |
    // |_________________________________________________________|
    //

    // Get the new line string
    char *eventLine = (type == REPORT_ERROR) ? newErrorLine() : newWarnLine();

    // Print the values of the event report's `eventPth` variable (debug)
    consoleDebug("EVENTReport -> eventPth: %s", eventPth);

    // Get the details about the file that contains the event that triggered this report
    char *eventFilePth;
    int eventFileLine, eventFileColumn;
    reportedFilePth(eventPth, &eventFilePth, &eventFileLine, &eventFileColumn);

    // Print the values of the rest of the event report's variables (debug)
    consoleDebug("EVENTReport -> caseEndColumn: %d", caseEndColumn);
    consoleDebug("EVENTReport -> caseHeight: %d", caseHeight);
    consoleDebug("EVENTReport -> reportMsg: %s", reportMsg);

    // Get the full event path string
    char *fullEventPth = fullReportPth(eventPth, eventLine);

    // Get the code block that triggered this report
    char *eventCodeBlock = reportCodeBlock(eventFilePth, eventFileLine, eventFileColumn,
                                                    caseHeight, caseEndColumn,
                                                    type);

    // Print the report in the console!
    reportConsole("%s%s%s%s\n\n%s\n", type,

    // Pass the report message
    reportMsg,
    
    // Pass the full message path
    ((consoleNoGray || !consoleColors) ? "" : CONSOLE_COLOR_GRAY),
    fullEventPth,
    ((consoleNoGray || !consoleColors) ? "" : CONSOLE_COLOR_RESET),

    // Pass the code block that caused this event
    eventCodeBlock);

    // Free up the memory used by the `eventCodeBlock` variable
    free(eventCodeBlock);

    // Free up the memory used by the `eventFilePth` variable
    free(eventFilePth);

    // Free up the memory used by the `fullEventPth` variable
    free(fullEventPth);

    // Free up the memory used by the `eventLine` variable
    free(eventLine);

    // Check if you're allowed to terminate this process!
    if(type == REPORT_ERROR && FLAG_CONSOLE_ERROR_MESSAGES_EXIT) {

        // Exit with a FAILURE state
        stopProcess(EXIT_FAILURE);

    }

}